# PART 2. Fill the gaps in the code.     

# Problem 1. Crowdfounding problem

# def find_min_pledge(pledge_list):
#     pledged_set = set(pledge_list)
#     min_pledge = 1
#     while min_pledge in pledged_set:
#         min_pledge += 1
#     return min_pledge

# print(find_min_pledge([1, 3, 6, 4, 1, 2]))
# print(find_min_pledge([1, 2, 3]))          
# print(find_min_pledge([-1, -3]))

# assert find_min_pledge([1, 3, 6, 4, 1, 2]) == 5
# assert find_min_pledge([1, 2, 3]) == 4
# assert find_min_pledge([-1, -3]) == 1


# ------------------------------------------------------------------------------- # # ------------------------------------------------------------------------------- #


# ------------------------------------------------------------------------------- # # ------------------------------------------------------------------------------- #



# Problem 2. Extract Titles from RSS feed

# import requests
# import re

# def url_news(rss_url):
#     response = requests.get(rss_url)
#     content = response.text
#     titles = re.findall(r'<title>(.*?)</title>', content)
#     return titles[1:] if titles else []
# google_url = "https://news.google.com/news/rss"
# print(url_news(google_url))




# ------------------------------------------------------------------------------- # # ------------------------------------------------------------------------------- #


# ------------------------------------------------------------------------------- # # ------------------------------------------------------------------------------- #



# Problem 3. Streaming Payments Processor

# import io

# # This is a library function, you can't modify it.
# def get_payments_storage():
#     """
#     @returns an instance of
#     https://docs.python.org/3/library/io.html#io.BufferedWriter
#     """
#     return open('test_output.txt', 'wb')  # Opens test_output.txt, writing in binary mode

# # This is a library function, you can't modify it.
# def stream_payments_to_storage(storage):
#     """
#     Loads payments and writes them to the `storage`.
#     Returns when all payments have been written.
#     @parameter `storage`: is an instance of
#     https://docs.python.org/3/library/io.html#io.BufferedWriter
#     """
#     for i in range(10):  # Loop 10 times
#         storage.write(bytes([1, 2, 3, 4, 5]))  # Write bytes to storage

# # Made a class for checksum to count
# class Checksumclass(io.BufferedWriter):
#     def __init__(self, writer):
#         super().__init__(writer)  # init with the provided writer
#         self.checksum = 0  # Init checksum value to 0

#     def write(self, writer):
#         self.checksum += sum(writer)  # Add sum of writer bytes to checksum
#         return super().write(writer)  # Write bytes to the fundamental storage

# def process_payments():
#     """
#     Modify `process_payments()` to print the checksum of data
#     generated by the `stream_payments_to_storage()` call.
#     """
#     original_storage = get_payments_storage()  # Get the storage request
#     checksum_storage = Checksumclass(original_storage)  # Wrap with Checksumclass
    
#     stream_payments_to_storage(checksum_storage)  # Process the payments
    
#     print(checksum_storage.checksum)  # print total bytes checksum 

# # Run the function for an output
# process_payments()


# ------------------------------------------------------------------------------- # # ------------------------------------------------------------------------------- #


# ------------------------------------------------------------------------------- # # ------------------------------------------------------------------------------- #


# Problem 4. Streaming Payments Processor, Two Vendors Edition.


# import io

# # This is a library function, you can't modify it.
# def stream_payments(callback_fn):
#     """
#     Reads payments from a payment processor and calls `callback_fn(amount)`
#     for each payment.
#     Returns when there is no more payments.
#     """

#     for i in range(10):
#         callback_fn(i)

# # This is a library function, you can't modify it.
# def store_payments(amount_iterator):
#     """
#     Iterates over the payment amounts from amount_iterator
#     and stores them to a remote system.
#     """
#     for i in amount_iterator:
#         print(i)                                     # print payment amount

# def process_payments_2():
#     # We need a generator function to store the payments
#     def payment_generator():
#         def collect_payments(amount):        # Callback to collect payments
#             nonlocal payments                # let function to modify the 'payments' list
#             payments.append(amount)          # append every payment into the list
#         payments = []                        # This is an empty list to store the payments
#         stream_payments(collect_payments)    # Stream and collect payments
#         for payment in payments:             # Yield each payment
#             yield payment
    
#     # Use the generator function to store payments into store_payments
#     store_payments(payment_generator())

# # Call the function for the output
# process_payments_2()

